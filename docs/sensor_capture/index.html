<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor Capture</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .status {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }
        .status.idle {
            background: #e3f2fd;
            color: #1976d2;
        }
        .status.recording {
            background: #ffebee;
            color: #c62828;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        button {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.2s;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            background: #45a049;
        }
        .btn-danger {
            background: #f44336;
            color: white;
        }
        .btn-danger:hover:not(:disabled) {
            background: #da190b;
        }
        .btn-secondary {
            background: #2196F3;
            color: white;
        }
        .btn-secondary:hover:not(:disabled) {
            background: #0b7dda;
        }
        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        .info-item {
            text-align: center;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 4px;
        }
        .info-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        .info-value {
            font-size: 20px;
            font-weight: bold;
            color: #333;
        }
        .sensor-display {
            font-family: monospace;
            font-size: 14px;
            background: #f9f9f9;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }
        .sensor-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        .warning {
            background: #fff3cd;
            color: #856404;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            border: 1px solid #ffeaa7;
        }
    </style>
</head>
<body>
    <h1>üì± Sensor Capture</h1>
    
    <div id="permissionWarning" class="warning" style="display: none;">
        ‚ö†Ô∏è Motion sensor access requires user permission. Click "Start Recording" to request access.
    </div>
    
    <div id="status" class="status idle">Ready</div>
    
    <div class="card">
        <button id="toggleBtn" class="btn-primary">Start Recording</button>
        <button id="exportBtn" class="btn-secondary" disabled>Export Data</button>
    </div>
    
    <div class="card">
        <h3 style="margin-top: 0;">Statistics</h3>
        <div class="info-grid">
            <div class="info-item">
                <div class="info-label">Sample Rate</div>
                <div class="info-value" id="sampleRate">0 Hz</div>
            </div>
            <div class="info-item">
                <div class="info-label">Duration</div>
                <div class="info-value" id="duration">0.0 s</div>
            </div>
            <div class="info-item">
                <div class="info-label">Accel Samples</div>
                <div class="info-value" id="accelCount">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">Gyro Samples</div>
                <div class="info-value" id="gyroCount">0</div>
            </div>
        </div>
    </div>
    
    <div class="card">
        <h3 style="margin-top: 0;">Current Values</h3>
        <div class="sensor-display">
            <div class="sensor-row">
                <span>Accel X:</span>
                <span id="accelX">0.00</span>
            </div>
            <div class="sensor-row">
                <span>Accel Y:</span>
                <span id="accelY">0.00</span>
            </div>
            <div class="sensor-row">
                <span>Accel Z:</span>
                <span id="accelZ">0.00</span>
            </div>
            <div class="sensor-row">
                <span>Gyro X:</span>
                <span id="gyroX">0.00</span>
            </div>
            <div class="sensor-row">
                <span>Gyro Y:</span>
                <span id="gyroY">0.00</span>
            </div>
            <div class="sensor-row">
                <span>Gyro Z:</span>
                <span id="gyroZ">0.00</span>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const DESIRED_FREQUENCY = 240; // Hz - request high frequency
        
        let isRecording = false;
        let startTime = null;
        let absoluteStartTime = null;
        let samples = [];
        let lastUpdateTime = 0;
        let sampleCount = 0;
        let currentRate = 0;
        let durationInterval = null;
        let accelerometer = null;
        let gyroscope = null;
        let usingSensorAPI = false;
        let hasFallenBack = false; // Prevent multiple fallback calls

        function updateUI() {
            document.getElementById('sampleRate').textContent = Math.round(currentRate) + ' Hz';
            
            const accelSamples = samples.filter(s => s.type === 'accel');
            const gyroSamples = samples.filter(s => s.type === 'gyro');
            
            document.getElementById('accelCount').textContent = accelSamples.length;
            document.getElementById('gyroCount').textContent = gyroSamples.length;
        }

        function updateDuration() {
            if (isRecording && startTime) {
                const elapsed = (performance.now() - startTime) / 1000;
                document.getElementById('duration').textContent = elapsed.toFixed(1) + ' s';
            }
        }

        // Handler for Sensor API (modern, high-frequency)
        function handleAccelerometer(reading) {
            if (!isRecording) return;
            
            const now = performance.now();
            const timestamp = (now - startTime) / 1000;
            
            samples.push({
                type: 'accel',
                timestamp: timestamp,
                x: reading.x || 0,
                y: reading.y || 0,
                z: reading.z || 0
            });
            
            document.getElementById('accelX').textContent = (reading.x || 0).toFixed(2);
            document.getElementById('accelY').textContent = (reading.y || 0).toFixed(2);
            document.getElementById('accelZ').textContent = (reading.z || 0).toFixed(2);
            
            updateSampleRate();
        }

        function handleGyroscope(reading) {
            if (!isRecording) return;
            
            const now = performance.now();
            const timestamp = (now - startTime) / 1000;
            
            samples.push({
                type: 'gyro',
                timestamp: timestamp,
                x: reading.x || 0,
                y: reading.y || 0,
                z: reading.z || 0
            });
            
            document.getElementById('gyroX').textContent = (reading.x || 0).toFixed(2);
            document.getElementById('gyroY').textContent = (reading.y || 0).toFixed(2);
            document.getElementById('gyroZ').textContent = (reading.z || 0).toFixed(2);
            
            updateSampleRate();
        }

        // Handler for DeviceMotion API (fallback, lower frequency)
        function handleMotion(event) {
            if (!isRecording) return;
            
            const now = performance.now();
            const timestamp = (now - startTime) / 1000;
            
            // Accelerometer data (with gravity)
            if (event.accelerationIncludingGravity) {
                const accel = event.accelerationIncludingGravity;
                samples.push({
                    type: 'accel',
                    timestamp: timestamp,
                    x: accel.x || 0,
                    y: accel.y || 0,
                    z: accel.z || 0
                });
                
                document.getElementById('accelX').textContent = (accel.x || 0).toFixed(2);
                document.getElementById('accelY').textContent = (accel.y || 0).toFixed(2);
                document.getElementById('accelZ').textContent = (accel.z || 0).toFixed(2);
            }
            
            // Gyroscope data (rotation rate)
            if (event.rotationRate) {
                const gyro = event.rotationRate;
                samples.push({
                    type: 'gyro',
                    timestamp: timestamp,
                    x: gyro.beta || 0,
                    y: gyro.gamma || 0,
                    z: gyro.alpha || 0
                });
                
                document.getElementById('gyroX').textContent = (gyro.beta || 0).toFixed(2);
                document.getElementById('gyroY').textContent = (gyro.gamma || 0).toFixed(2);
                document.getElementById('gyroZ').textContent = (gyro.alpha || 0).toFixed(2);
            }
            
            updateSampleRate();
        }

        function updateSampleRate() {
            const now = performance.now();
            sampleCount++;
            if (now - lastUpdateTime >= 1000) {
                currentRate = sampleCount / ((now - lastUpdateTime) / 1000);
                sampleCount = 0;
                lastUpdateTime = now;
                updateUI();
            }
        }

        async function requestPermission() {
            // Request DeviceMotion permission (iOS)
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceMotionEvent.requestPermission();
                    if (permission !== 'granted') {
                        return false;
                    }
                } catch (error) {
                    console.error('DeviceMotion permission request failed:', error);
                    return false;
                }
            }
            
            // Request Sensor API permissions (if needed)
            if (typeof Accelerometer !== 'undefined') {
                try {
                    const result = await navigator.permissions.query({ name: 'accelerometer' });
                    if (result.state === 'denied') {
                        return false;
                    }
                } catch (error) {
                    // Permission query may not be supported, continue anyway
                    console.log('Accelerometer permission query not supported:', error);
                }
            }
            
            if (typeof Gyroscope !== 'undefined') {
                try {
                    const result = await navigator.permissions.query({ name: 'gyroscope' });
                    if (result.state === 'denied') {
                        return false;
                    }
                } catch (error) {
                    // Permission query may not be supported, continue anyway
                    console.log('Gyroscope permission query not supported:', error);
                }
            }
            
            return true;
        }

        async function startRecording() {
            const granted = await requestPermission();
            
            if (!granted) {
                alert('Motion sensor permission denied. Cannot record data.');
                return;
            }
            
            samples = [];
            startTime = performance.now();
            absoluteStartTime = new Date();
            lastUpdateTime = startTime;
            sampleCount = 0;
            currentRate = 0;
            isRecording = true;
            
            document.getElementById('status').textContent = 'Recording...';
            document.getElementById('status').className = 'status recording';
            document.getElementById('toggleBtn').textContent = 'Stop Recording';
            document.getElementById('toggleBtn').className = 'btn-danger';
            document.getElementById('exportBtn').disabled = true;
            
            // Try to use Sensor API first (higher frequency, better precision)
            usingSensorAPI = false;
            hasFallenBack = false;
            
            if (typeof Accelerometer !== 'undefined' && typeof Gyroscope !== 'undefined') {
                try {
                    // Create sensors with high frequency
                    // Try with referenceFrame first, fall back without it if not supported
                    let sensorOptions = { frequency: DESIRED_FREQUENCY };
                    try {
                        accelerometer = new Accelerometer({ ...sensorOptions, referenceFrame: 'device' });
                        gyroscope = new Gyroscope({ ...sensorOptions, referenceFrame: 'device' });
                    } catch (e) {
                        console.log('referenceFrame not supported, using default');
                        accelerometer = new Accelerometer(sensorOptions);
                        gyroscope = new Gyroscope(sensorOptions);
                    }
                    
                    accelerometer.addEventListener('reading', () => handleAccelerometer(accelerometer));
                    gyroscope.addEventListener('reading', () => handleGyroscope(gyroscope));
                    
                    // Track errors to fall back to DeviceMotion if sensors don't work
                    accelerometer.addEventListener('error', (event) => {
                        console.error('Accelerometer error:', event.error);
                        if (!hasFallenBack && isRecording) {
                            console.log('Sensor API failed, falling back to DeviceMotion API');
                            fallbackToDeviceMotion();
                        }
                    });
                    
                    gyroscope.addEventListener('error', (event) => {
                        console.error('Gyroscope error:', event.error);
                        if (!hasFallenBack && isRecording) {
                            console.log('Sensor API failed, falling back to DeviceMotion API');
                            fallbackToDeviceMotion();
                        }
                    });
                    
                    accelerometer.start();
                    gyroscope.start();
                    
                    usingSensorAPI = true;
                    console.log(`Using Sensor API with ${DESIRED_FREQUENCY} Hz frequency`);
                    document.getElementById('status').textContent = `Recording... (Sensor API @ ${DESIRED_FREQUENCY}Hz)`;
                } catch (error) {
                    console.error('Failed to start Sensor API:', error);
                    usingSensorAPI = false;
                    accelerometer = null;
                    gyroscope = null;
                }
            }
            
            // Fall back to DeviceMotion API if Sensor API not available
            if (!usingSensorAPI) {
                console.log('Using DeviceMotion API (fallback)');
                window.addEventListener('devicemotion', handleMotion);
                document.getElementById('status').textContent = 'Recording... (DeviceMotion API)';
            }
            
            durationInterval = setInterval(updateDuration, 100);
        }
        
        function fallbackToDeviceMotion() {
            if (!isRecording || !usingSensorAPI || hasFallenBack) return;
            
            hasFallenBack = true; // Prevent multiple calls
            
            // Stop Sensor API
            if (accelerometer) {
                try { 
                    accelerometer.stop(); 
                } catch (e) {
                    console.log('Error stopping accelerometer:', e);
                }
                accelerometer = null;
            }
            if (gyroscope) {
                try { 
                    gyroscope.stop(); 
                } catch (e) {
                    console.log('Error stopping gyroscope:', e);
                }
                gyroscope = null;
            }
            
            usingSensorAPI = false;
            
            // Start DeviceMotion API
            console.log('Now using DeviceMotion API');
            window.addEventListener('devicemotion', handleMotion);
            document.getElementById('status').textContent = 'Recording... (DeviceMotion API)';
        }

        function stopRecording() {
            isRecording = false;
            
            // Stop Sensor API if used
            if (usingSensorAPI) {
                if (accelerometer) {
                    accelerometer.stop();
                    accelerometer = null;
                }
                if (gyroscope) {
                    gyroscope.stop();
                    gyroscope = null;
                }
            } else {
                window.removeEventListener('devicemotion', handleMotion);
            }
            
            if (durationInterval) {
                clearInterval(durationInterval);
                durationInterval = null;
            }
            
            updateDuration();
            
            document.getElementById('status').textContent = 'Stopped - ' + samples.length + ' samples collected';
            document.getElementById('status').className = 'status idle';
            document.getElementById('toggleBtn').textContent = 'Start Recording';
            document.getElementById('toggleBtn').className = 'btn-primary';
            document.getElementById('exportBtn').disabled = samples.length === 0;
        }

        function exportData() {
            if (samples.length === 0) {
                alert('No data to export');
                return;
            }
            
            const accelSamples = samples.filter(s => s.type === 'accel').map(s => ({
                timestamp: s.timestamp,
                x: s.x,
                y: s.y,
                z: s.z
            }));
            
            const gyroSamples = samples.filter(s => s.type === 'gyro').map(s => ({
                timestamp: s.timestamp,
                x: s.x,
                y: s.y,
                z: s.z
            }));
            
            const duration = samples.length > 0 ? samples[samples.length - 1].timestamp : 0;
            
            const data = {
                metadata: {
                    device: navigator.userAgent,
                    platform: navigator.platform,
                    recorded_at: absoluteStartTime.toISOString(),
                    absolute_start_time: absoluteStartTime.toISOString(),
                    absolute_start_timestamp_ms: absoluteStartTime.getTime(),
                    duration_seconds: duration,
                    sample_count: samples.length,
                    accelerometer_count: accelSamples.length,
                    gyroscope_count: gyroSamples.length,
                    average_sample_rate: duration > 0 ? samples.length / duration : 0
                },
                accelerometer: accelSamples,
                gyroscope: gyroSamples
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const timestamp = absoluteStartTime.toISOString().replace(/[:.]/g, '-').split('T')[0] + '_' + 
                             absoluteStartTime.toTimeString().split(' ')[0].replace(/:/g, '-');
            const filename = `sensor_data_${timestamp}.json`;
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            
            URL.revokeObjectURL(url);
        }

        document.getElementById('toggleBtn').addEventListener('click', () => {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        });

        document.getElementById('exportBtn').addEventListener('click', exportData);

        // Check sensor capabilities and display info
        if (typeof DeviceMotionEvent === 'undefined' && typeof Accelerometer === 'undefined') {
            document.getElementById('status').textContent = 'Motion sensors not available';
            document.getElementById('status').className = 'status idle';
            document.getElementById('toggleBtn').disabled = true;
        } else {
            // Show which APIs are available
            const apis = [];
            if (typeof Accelerometer !== 'undefined' && typeof Gyroscope !== 'undefined') {
                apis.push('Sensor API (high-freq)');
            }
            if (typeof DeviceMotionEvent !== 'undefined') {
                apis.push('DeviceMotion API');
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    document.getElementById('permissionWarning').style.display = 'block';
                }
            }
            
            if (apis.length > 0) {
                console.log('Available sensor APIs:', apis.join(', '));
            }
        }
    </script>
</body>
</html>
