<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Component Tests - DDR Accelero</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-section h2 {
            color: #667eea;
            margin-top: 0;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .test-pass {
            background: #d4edda;
            color: #155724;
        }
        .test-fail {
            background: #f8d7da;
            color: #721c24;
        }
        pre {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>ðŸ§ª DDR Accelero Component Tests</h1>
    <p>This page tests individual components of the web application.</p>

    <div class="test-section">
        <h2>1. SM Parser Tests</h2>
        <div id="smParserTests"></div>
    </div>

    <div class="test-section">
        <h2>2. Inference Engine Tests</h2>
        <div id="inferenceTests"></div>
    </div>

    <div class="test-section">
        <h2>3. Visualization Tests</h2>
        <div id="visualizationTests"></div>
    </div>

    <script src="sm-parser.js"></script>
    <script src="inference.js"></script>
    <script src="visualization.js"></script>
    
    <script>
        // Test utilities
        function testResult(name, passed, details = '') {
            const div = document.createElement('div');
            div.className = `test-result ${passed ? 'test-pass' : 'test-fail'}`;
            div.innerHTML = `
                <strong>${passed ? 'âœ“' : 'âœ—'} ${name}</strong>
                ${details ? `<br><pre>${details}</pre>` : ''}
            `;
            return div;
        }

        // SM Parser Tests
        function runSMParserTests() {
            const container = document.getElementById('smParserTests');
            const parser = new SMParser();

            // Test 1: Parser initialization
            try {
                container.appendChild(testResult('Parser initialization', true));
            } catch (e) {
                container.appendChild(testResult('Parser initialization', false, e.message));
            }

            // Test 2: BPM extraction from sample content
            try {
                const sampleSM = `
#TITLE:Test Song;
#ARTIST:Test Artist;
#BPMS:0.000=120.000;
#NOTES:
dance-single:
:Medium:
5:
:
0100
1000
0010
0001
,
1000
0100
;
`;
                parser.parse(sampleSM, 5, 'Medium');
                const passed = parser.bpm === 120;
                container.appendChild(testResult(
                    'BPM extraction',
                    passed,
                    `Expected: 120, Got: ${parser.bpm}`
                ));
            } catch (e) {
                container.appendChild(testResult('BPM extraction', false, e.message));
            }

            // Test 3: Arrow extraction
            try {
                const hasArrows = parser.arrows.length > 0;
                container.appendChild(testResult(
                    'Arrow extraction',
                    hasArrows,
                    `Extracted ${parser.arrows.length} arrows`
                ));
            } catch (e) {
                container.appendChild(testResult('Arrow extraction', false, e.message));
            }

            // Test 4: Arrow format validation
            try {
                if (parser.arrows.length > 0) {
                    const firstArrow = parser.arrows[0];
                    const hasTime = typeof firstArrow.time === 'number';
                    const hasArrows = Array.isArray(firstArrow.arrows) && firstArrow.arrows.length === 4;
                    const passed = hasTime && hasArrows;
                    container.appendChild(testResult(
                        'Arrow format validation',
                        passed,
                        `First arrow: ${JSON.stringify(firstArrow, null, 2)}`
                    ));
                } else {
                    container.appendChild(testResult('Arrow format validation', false, 'No arrows to validate'));
                }
            } catch (e) {
                container.appendChild(testResult('Arrow format validation', false, e.message));
            }
        }

        // Inference Engine Tests
        async function runInferenceTests() {
            const container = document.getElementById('inferenceTests');
            
            // Test 1: Engine initialization
            try {
                const engine = new InferenceEngine();
                await engine.initialize();
                container.appendChild(testResult(
                    'Engine initialization',
                    engine.isModelLoaded,
                    'Demo mode active'
                ));
            } catch (e) {
                container.appendChild(testResult('Engine initialization', false, e.message));
            }

            // Test 2: Demo prediction with synthetic data
            try {
                const engine = new InferenceEngine();
                await engine.initialize();

                // Create synthetic sensor data
                const numSamples = 1000;
                const sensorData = {
                    time: Array.from({length: numSamples}, (_, i) => i / 100),
                    acc_x: new Float32Array(numSamples).map(() => Math.random() * 10 - 5),
                    acc_y: new Float32Array(numSamples).map(() => Math.random() * 10 - 5),
                    acc_z: new Float32Array(numSamples).map(() => Math.random() * 10 - 5),
                    gyro_x: new Float32Array(numSamples),
                    gyro_y: new Float32Array(numSamples),
                    gyro_z: new Float32Array(numSamples),
                    mag_x: new Float32Array(numSamples),
                    mag_y: new Float32Array(numSamples),
                    mag_z: new Float32Array(numSamples)
                };

                const predictions = await engine.predict(sensorData, 0, 10);
                const passed = Array.isArray(predictions) && predictions.length >= 0;
                container.appendChild(testResult(
                    'Demo prediction',
                    passed,
                    `Generated ${predictions.length} predictions`
                ));
            } catch (e) {
                container.appendChild(testResult('Demo prediction', false, e.message));
            }

            // Test 3: Prediction format validation
            try {
                const engine = new InferenceEngine();
                await engine.initialize();

                const numSamples = 1000;
                const sensorData = {
                    time: Array.from({length: numSamples}, (_, i) => i / 100),
                    acc_x: new Float32Array(numSamples).map(() => Math.random() * 10 - 5),
                    acc_y: new Float32Array(numSamples).map(() => Math.random() * 10 - 5),
                    acc_z: new Float32Array(numSamples).map(() => Math.random() * 10 - 5),
                    gyro_x: new Float32Array(numSamples),
                    gyro_y: new Float32Array(numSamples),
                    gyro_z: new Float32Array(numSamples),
                    mag_x: new Float32Array(numSamples),
                    mag_y: new Float32Array(numSamples),
                    mag_z: new Float32Array(numSamples)
                };

                const predictions = await engine.predict(sensorData, 0, 10);
                
                if (predictions.length > 0) {
                    const pred = predictions[0];
                    const hasTime = typeof pred.time === 'number';
                    const hasArrows = Array.isArray(pred.arrows) && pred.arrows.length === 4;
                    const passed = hasTime && hasArrows;
                    container.appendChild(testResult(
                        'Prediction format',
                        passed,
                        `Sample prediction: ${JSON.stringify(pred, null, 2)}`
                    ));
                } else {
                    container.appendChild(testResult('Prediction format', true, 'No predictions generated (acceptable)'));
                }
            } catch (e) {
                container.appendChild(testResult('Prediction format', false, e.message));
            }
        }

        // Visualization Tests
        function runVisualizationTests() {
            const container = document.getElementById('visualizationTests');

            // Test 1: Visualizer initialization
            try {
                // Create test container
                const testDiv = document.createElement('div');
                testDiv.id = 'testViz';
                testDiv.style.display = 'none';
                document.body.appendChild(testDiv);

                const viz = new ArrowVisualizer('testViz');
                container.appendChild(testResult('Visualizer initialization', true));
            } catch (e) {
                container.appendChild(testResult('Visualizer initialization', false, e.message));
            }

            // Test 2: Create visualization with sample data
            try {
                const testDiv = document.getElementById('testViz') || document.createElement('div');
                testDiv.id = 'testViz';
                if (!testDiv.parentNode) document.body.appendChild(testDiv);

                const viz = new ArrowVisualizer('testViz');
                
                const samplePredictions = [
                    {time: 0.5, arrows: [1, 0, 0, 0]},
                    {time: 1.0, arrows: [0, 1, 0, 0]},
                    {time: 1.5, arrows: [0, 0, 1, 0]},
                    {time: 2.0, arrows: [0, 0, 0, 1]}
                ];

                const sampleGroundTruth = [
                    {time: 0.5, arrows: [1, 0, 0, 0]},
                    {time: 1.0, arrows: [0, 1, 0, 0]},
                    {time: 1.5, arrows: [0, 0, 1, 0]},
                    {time: 2.0, arrows: [0, 0, 0, 1]}
                ];

                viz.visualize(samplePredictions, sampleGroundTruth, 3.0);
                
                const hasSVG = testDiv.querySelectorAll('svg').length > 0;
                container.appendChild(testResult(
                    'Create visualization',
                    hasSVG,
                    `SVG elements: ${testDiv.querySelectorAll('svg').length}`
                ));
            } catch (e) {
                container.appendChild(testResult('Create visualization', false, e.message));
            }
        }

        // Run all tests
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('Running component tests...');
            runSMParserTests();
            await runInferenceTests();
            runVisualizationTests();
            console.log('Tests complete!');
        });
    </script>
</body>
</html>
